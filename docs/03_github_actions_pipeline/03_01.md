---
title: '1. Create and run a GitHub Actions Workflow'
layout: default
nav_order: 1
parent: 'Exercise 03: Build and Deploy a GitHub Actions CI/CD Pipeline'
---

# Task 01 - Create and run a GitHub Actions Workflow

## Description

In this task you will automate the deployment of Zava's .NET app to Azure App Service for Containers using GitHub Actions. 

## Success Criteria

- You have created and executed a GitHub Actions workflow
- The workflow results have completed the following steps:
  - Built and containerized the solution
  - Pushed the image to the Azure Container Registry (ACR)
  - Deployed the application to the App Service

## Learning Resources

## Key Tasks

### 01: Ask Copilot to create a GitHub Actions Workflow

From Visual Studio Code, you will prompt GitHub Copilot to create a GitHub Actions workflow that will: 

- Build and deploy the Zava application as a container to the App Service previously deployed in Exercise 2
- Add the workflow to the existing `/infra` folder
- Create a readme explaining how to configure GitHub secrets and variables

<details markdown="block">
<summary><strong>Expand this section for detailed steps</strong></summary>

In Visual Studio Code ‚Üí Copilot Chat type a prompt such as the following:

```text
Create a minimal quickstart GitHub Actions workflow to build and deploy this dotnet app as a container to
the app service I've already defined in the infra folder.  Include a minimal readme explaining how to
configure GitHub secrets and variables but no other scripts or files.
```

Copilot should create a workflow YAML file in the folder `.github/workflows`. The file name may vary but it might be something like `deploy-dotnet-app.yml`.

The following image illustrates an example Copilot interaction for this step.

![Copilot interaction to create workflow YAML](../../media/0301_copilot_workflow_yaml.png)

The following image illustrates the resulting folders and files that should be created:
![Copilot generated files after creating the workflow](../../media/0301_copilot_workflow_yaml_1.png)
</details>

### 02: Add the Workflow to GitHub Actions

By default, workflows do not appear in GitHub Actions unless they have been merged to the default branch. As a workaround you can add a Pull Request trigger and open a Pull Request to test the workflow before merging. 

Review the workflow YAML file and if a Pull Request trigger is not present, add it. 

<details markdown="block">
<summary><strong>Expand this section for detailed steps</strong></summary>

Find the triggers at the top of the file and add check to see if a `pull_request` trigger exists (Copilot may have added it already). See the example below. If the trigger is missing, add it. 

```yaml
on:
  push:
    branches: [ main ]
    paths: [ 'src/**' ]
  pull_request:
    branches: [ '*' ]
  workflow_dispatch:
```

The full view of a workflow YAML output is shown here: 

```yaml
name: Build and Deploy to Azure App Service

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: ${{ vars.AZURE_CONTAINER_REGISTRY_NAME }}.azurecr.io
  IMAGE_NAME: simplestore
  APP_NAME: ${{ vars.AZURE_APP_SERVICE_NAME }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Log in to Azure
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Log in to Azure Container Registry
      run: az acr login --name ${{ vars.AZURE_CONTAINER_REGISTRY_NAME }}

    - name: Build and push Docker image
      run: |
        # Build the Docker image
        docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest ./src

        # Push both tags to registry
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

    - name: Deploy to Azure App Service
      uses: azure/webapps-deploy@v3
      with:
        app-name: ${{ env.APP_NAME }}
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
```

</details>

### 03: Review the generated deployment README file 

Because our prompt asked Copilot to document the necessary steps to configure variables and secrets, GitHub Copilot should have created a README explaining the next steps. 

Find your deployment README and follow the steps inside to setup your GitHub secrets and variables, these will typically include:
- Azure Credentials
- Azure Container Registry Name
- Azure App Service Name

> **NOTE** Based on the choices Copilot makes during the generation of the workflow YAML, specific secret and variable names may different for each person. In addition, there may be more or less details depending on the approach Copilot took to generate the results.

<details markdown="block">
<summary><strong>Expand this section to view a sample README</strong></summary>

# GitHub Actions Deployment Setup

This repository contains a GitHub Actions workflow that automatically builds and deploys your .NET application as a container to Azure App Service.

## Prerequisites

Before the workflow can run successfully, you need to configure the following GitHub secrets and variables:

### Required GitHub Secrets

1. **AZURE_CREDENTIALS** - Azure service principal credentials for authentication

   To create this secret:

   ```bash
   # Create a service principal with contributor access to your resource group
   az ad sp create-for-rbac --name "github-actions-sp" \
     --role contributor \
     --scopes /subscriptions/{subscription-id}/resourceGroups/{resource-group-name} \
     --json-auth
   ```

   Copy the entire JSON output and paste it as the value for the `AZURE_CREDENTIALS` secret.

### Required GitHub Variables

1. **AZURE_CONTAINER_REGISTRY_NAME** - The name of your Azure Container Registry (without .azurecr.io)
2. **AZURE_APP_SERVICE_NAME** - The name of your Azure App Service

### How to Configure Secrets and Variables

1. Go to your GitHub repository
2. Click on **Settings** ‚Üí **Secrets and variables** ‚Üí **Actions**
3. Add the secret under the **Secrets** tab
4. Add the variables under the **Variables** tab

### Service Principal Permissions

The service principal needs the following permissions:
- **Contributor** role on the resource group (for App Service deployment)
- **AcrPush** role on the Azure Container Registry (for pushing container images)

To assign the ACR role:
```bash
az role assignment create \
  --assignee {service-principal-client-id} \
  --role AcrPush \
  --scope /subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/Microsoft.ContainerRegistry/registries/{acr-name}
```

## Workflow Behavior

The workflow triggers on:
- Push to `main` branch
- Pull requests to `main` branch
- Manual trigger via GitHub UI

The workflow will:
1. Build your .NET application as a Docker container
2. Push the container to your Azure Container Registry
3. Deploy the container to your Azure App Service

## Finding Your Resource Names

You can find your resource names by running:
```bash
# List your resource groups
az group list --output table

# List resources in your resource group
az resource list --resource-group {your-resource-group-name} --output table
```

Look for resources with types:
- `Microsoft.ContainerRegistry/registries` (for ACR name)
- `Microsoft.Web/sites` (for App Service name)

</details>

### 04: Commit and push your workflow file

After reviewing, you will commit the changes to the repository feature branch created in Exercise 2. 

> **Note**: Make sure you're pushing to the correct branch. You should have a feature branch created in Exercise 2. This will support the next step where you will create a Pull Request to test this workflow before merging to main.

<details markdown="block">
<summary><strong>Expand this section for detailed steps using Terminal</strong></summary>

1. **Check Current Status**
   - Open the integrated terminal in Visual Studio Code (Terminal ‚Üí New Terminal)
   - Check what files have been modified:
   ```bash
   git status
   ```

2. **Add the Workflow File**
   - Add your new workflow file to the staging area:
   ```bash
   git add .github/workflows/
   ```
   - Or add all modified files:
   ```bash
   git add .
   ```

3. **Commit Your Changes**
   - Create a commit with a descriptive message:
   ```bash
   git commit -m "Add GitHub Actions workflow for .NET app deployment to Azure"
   ```

4. **Push to Your Branch**
   - If you're on a feature branch (like `dev`):
   ```bash
   git push origin dev
   ```
   - If you're on the main branch:
   ```bash
   git push origin main
   ```

5. **Verify the Push**
   - Check that your changes were pushed successfully:
   ```bash
   git log --oneline -5
   ```
   - You should see your commit at the top of the list
</summary>
</details>

<details markdown="block">
<summary><strong>Expand this section for detailed steps using Git integration</strong></summary>

1. **Open Source Control Panel**
   - Click the Source Control icon in the left sidebar (or press `Ctrl+Shift+G`)

2. **Review Changes**
   - You'll see your modified files listed under "Changes"
   - Review the workflow file to ensure it's correct

3. **Stage Changes**
   - Click the `+` button next to each file to stage it
   - Or click the `+` button next to "Changes" to stage all files

4. **Commit Changes**
   - Enter a commit message in the text box: "Add GitHub Actions workflow for .NET app deployment to Azure"
   - Press `Ctrl+Enter` or click the checkmark button to commit

5. **Push Changes**
   - Click the "..." menu in the Source Control panel
   - Select "Push" to push your changes to the remote repository

</summary>
</details>

### 05 Create a Pull Request to test the workflow

Create a Pull Request to merge the changes. This will trigger the workflow. 

<details markdown="block">
<summary><strong>Expand this section for detailed steps</strong></summary>

1. **Navigate to Your Repository**
   - Go to your GitHub repository in a web browser
   - Make sure you can see your recently pushed branch (e.g., `dev`)

2. **Create Pull Request**
   - You should see a yellow banner saying "Your recently pushed branches" with a **Compare & pull request** button
   - Click **Compare & pull request**
   - If you don't see the banner, click the **Pull requests** tab, then **New pull request**

3. **Configure the Pull Request**
   - **Base branch**: Select `main` (the branch you want to merge into)
   - **Compare branch**: Select your feature branch (e.g., `dev`)
   - **Title**: Enter something like "Add GitHub Actions workflow for Azure deployment"
   - **Description**: Add details about what the workflow does:
     ```
     This PR adds a GitHub Actions workflow that:
     - Builds and containerizes the .NET app
     - Pushes images to Azure Container Registry
     - Deploys to Azure App Service for Containers
     - Includes proper authentication and variable configuration
     ```

4. **Create the Pull Request**
   - Click **Create pull request** (don't click "Create draft pull request")
   - The workflow should automatically trigger due to the `pull_request` trigger in your YAML

</details>

### 06 Verify workflow execution

From your repository on GitHub, check the Actions tab to see your workflow running. Click on the workflow to see detailed logs and watch it execute. 

![Workflow execution details](../../media/0301_workflow_details.png)

<details markdown="block">
<summary><strong>Expand this section for detailed steps</strong></summary>

1. **Check Actions Tab**
   - Go to your repository on GitHub
   - Click the **Actions** tab
   - You should see your workflow running (it will show as "in progress" with a yellow circle)

2. **Monitor the Workflow**
   - Click on the workflow run to see detailed logs
   - Watch each step execute:
     - Checkout code
     - Log in to Azure
     - Build and push Docker image
     - Deploy to Azure App Service

3. **Check Pull Request Status**
   - Return to your Pull Request
   - You'll see a status check showing the workflow progress
   - Green checkmark = success, Red X = failure

</details>

> **NOTE** You can execute the workflow on the Pull Request without impacting the main branch.
> - **Don't merge yet**: The workflow will run on the PR, allowing you to test without affecting the main branch
> - **Multiple runs**: You can push additional commits to your branch to trigger more workflow runs
> - **Debugging**: If the workflow fails, check the logs in the Actions tab for detailed error messages
> 
> The `pull_request` trigger in your workflow YAML is what makes this possible. This allows you to test deployments safely before merging to main.

4. **Check the results of the workflow**

View your workflow in action. Does it succeed or fail? 

If your workflow fails it could be a problem with the workflow YAML itself, the secrets and variables configuration, or even due to infrastructure configuration problems that only present at application deploy time rather than provisioning time.

</details>

<details markdown="block">
<summary><strong>Expand this section for additional workflow monitoring tips</strong></summary>

The following describes additional tips for monitoring workflow execution. 

1. **Access GitHub Actions**
   - Go to your GitHub repository in a web browser
   - Click the **Actions** tab in the top navigation
   - You should see your workflow run listed with a status indicator:
     - üü° Yellow circle = In progress
     - ‚úÖ Green checkmark = Success
     - ‚ùå Red X = Failed
     - ‚è∏Ô∏è Gray circle = Queued/waiting

2. **View Workflow Details**
   - Click on the workflow run name (e.g., "Add GitHub Actions workflow for Azure deployment")
   - This opens the workflow run summary page showing:
     - Overall status
     - Duration
     - Jobs and their status
     - Triggered by information

3. **Examine Job Steps**
   - Click on the job name (e.g., "build-and-deploy")
   - This shows all individual steps with their status:
     - Checkout code
     - Log in to Azure
     - Log in to Azure Container Registry
     - Build and push Docker image
     - Deploy to Azure App Service
     - Restart App Service

4. **Review Step Logs**
   - Click on any step to expand its logs
   - Look for error messages, warnings, or success confirmations
   - Pay special attention to the output of each command

</details>


### 07: Success Indicators

Your workflow has succeeded when:

‚úÖ **All Steps Complete Successfully**
- Each step shows a green checkmark
- No error messages in the logs

‚úÖ **Container Image Built and Pushed**
- Docker build completes without errors
- Images pushed to Azure Container Registry

‚úÖ **App Service Deployment Successful**
- Deployment action completes
- App service restart succeeds

‚úÖ **Application Responds**
- Visit your app URL: `https://<your-app-name>.azurewebsites.net`
- App loads without errors (may take a few minutes after deployment)

### 08: Next Steps After Success

1. **Test Your Application**
   - Browse to your app URL
   - Verify all functionality works as expected

2. **Monitor Application Insights**
   - Check for any runtime errors or performance issues

3. **Merge Your Pull Request**
   - If everything works correctly, merge your PR to main
   - This will trigger the workflow on the main branch

### 09: Next Steps After Failure

1. **Review Error Messages**
   - Identify the specific step that failed
   - Note the exact error message

2. **Apply Fixes**
   - Make necessary changes to workflow YAML, secrets, or variables
   - Commit and push changes to trigger a new workflow run

3. **Iterate Until Success**
   - Repeat the process until your workflow succeeds
   - Use Copilot Chat to help diagnose complex issues

> **Pro Tip**: Keep workflow runs for future reference. GitHub retains workflow run logs for 90 days, which can be helpful for debugging similar issues later.

> **NOTE** The next two tasks in this exercise will explain additional troubleshooting methods.